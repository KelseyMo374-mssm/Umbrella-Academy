---
title: "Making (Nice!) Plots in R"
subtitle: "An R exercise within the Umbrella Academy course"
description: "This is an exercise to help 'wet lab' scientists feel comfortable manipulating data and creating common charts in R"

author:
  - name: Kelsey Monson
    degrees:
      - PhD
      - MS
    orcid: 0000-0003-1093-8628
    email: kelsey.monson@mssm.edu
    affiliations:
      - ref: ISMMS

affiliations:
  - id: ISMMS
    name: Icahn School of Medicine at Mount Sinai
    city: New York
    state: NY
    department: Immunology and Immunotherapy

title-block-banner: "#f0f3f5"
title-block-banner-color: "black"

keywords: "R, Data Analysis, Data Viz"
date: today

format: 
  html: 
    toc: true
    number-sections: true
    css: style.css
    code-overflow: wrap
    
fig-cap-location: margin
execute: 
  warning: false
editor: visual
---

## Introduction

**The Umbrella Academy** aims to introduce "wet lab" scientists to useful "dry lab" tools. Therefore, this exercise is designed to enable students to generate aesthetically pleasing plots in R.

While it has many functions (too many to cover int today's course), R is an excellent tool for generating beautiful data visualizations. It's much more flexible and customizable than other tools like Excel or GraphPad, plus it's free and open-source, unlike pricey proprietary statistical software like SAS or STATA.

Before diving into the exercise, let's cover the basics of using R and RStudio.

### R and RStudio

By now, you should have installed what's often called **"Base-R."**

**What is R?**

According to its creators,

> R is "a language and environment for statistical computing and graphics" and "an integrated suite of software facilities for data manipulation, calculation and graphical display."

(You can read more about it [here](https://www.r-project.org/about.html).)

But what does that mean in practice?

Launching R might remind you of the early 2000s with its retro interface:

![**Base R GUI.** This always reminds me of an AIM chat window (if anyone is old enough to remember that).](assets/RGui.png)

"Base-R" is not especially user-friendly (where do you even begin? how do you run a command?). While it's perfectly functional, it's not the ideal way to interact with R.

Enter: **RStudio**.

I'm writing this exercise in RStudio right now, see? ![RStudio screenshot](assets/RStudio.png)

To be honest, I've been coding in R since 2017 and have never once written a script or performed an analysis in Base-R.

Maybe you can see why -- RStudio is an **"integrative development environment" (IDE).**

It's more than a "graphical user interface" (GUI) -- RStudio lets you write, run, and debug R code, manage files and variables with ease, render plots, read help documentation... the list goes on.

We'll explore RStudio in depth throughout the exercise, but first we need to learn a bit more about how R works.

### Data Types and Variables

This section might feel familiar if you've taken a basic programming class (or done your [homework](https://vscodeedu.com/courses/intro-to-python), though R and Python differ a bit).

I'll try to make this brief:

#### Variable Structures in R

-   **Data Frame:** A table with rows and columns. Each column can store different data types, making it ideal for organizing datasets.
-   **Tibble:** A modernized Data Frame. Your data looks prettier when printed and there are no row names by default.
-   **Vector:** A one-dimensional collection with elements of the same data type.
-   **List:** An ordered collection that can store mixed data types.
-   **Matrix:** A two-dimensional Vector with rows and columns, with elements of the same type.
-   **Array:** Like a Matrix but can handle more than two dimensions.

You'll most often use **Data Frames** or **Tibbles** to create figures, but will use all the variable types at one point or another.

#### Data Types in R

-   **Numeric:** The default for numbers, including decimals.
-   **Factor:** A special structure for categorical data with defined values.
-   **Integer:** Whole numbers (can be explicitly defined with an "L" suffix, e.g., `10L`).
-   **Logical:** Boolean values: `TRUE` or `FALSE`.
-   **Character:** Text strings.
-   **Complex:** Numbers with both real and imaginary components (e.g., `2+3i`).
-   **Raw:** Raw byte data.

**Numeric**, **Factor**, and **Character** variables are essential for plotting data. **Factors** are especially important -- we'll explore them more soon.

These definitions are drawn from [this R Workshop GitHub](https://github.com/MVesuviusC/R_workshop/tree/main), which inspired a few other sections of this class (thank you, [MVesuviusC](https://github.com/MVesuviusC)!).

#### The `str()` function

The `str()` function reveals an object's structure.

Let's compare a **Numeric** variable and an **Integer** by creating two **Vectors**:

```{r}
# Create the vectors
numbr <- c(1,2,3)
intg <- c(1L,2L,3L)

# Look at their structure with `str()`
str(numbr)
str(intg)
```

Breaking it down, we

1.  Created the variables using `<-` (the `assignment operator`).
2.  Used the combine function `c()` to combine numbers/integers into new variables.
3.  Passed each variable to `str()` to check its structure.

R syntax is typically the `function` followed by the arguments to the function in parentheses: `(arguments)`.

You can also *coerce* one data type into another.

```{r}
# Let's say I actually wanted `numbr` to be an integer:
numbr <- as.integer(numbr)
str(numbr)

# Or even a character:
numbr <- as.character(numbr)
str(numbr)
```

But, oops, just kidding, I actually wanted `numbr` to be numeric. We can change it back:

```{r}
numbr <- as.numeric(numbr)
str(numbr)
```

::: callout-warning
**Be careful not to coerce a variable into an impossible data type!**
:::

Note what happens if we try to coerce a character vector into a numeric vector, even if the character *could* represent a number:

```{r}
number <- c("one","two","three")
str(number)

number <- as.numeric(number)
str(number)
```

R isn't reading and interpreting what our characters might mean, so it isn't going to automatically convert `one` into `1`.

If you have numeric variables in your dataset, it's best to save them as numbers in your raw data and treat them as either numeric or integer variables in R.

#### Why use **Factors**?

::: callout-caution
**R treats text variables alphabetically by default** unless we specify otherwise.

Here's an example where that might become confusing.

Say we had a dataset from a contest, where participants could place first, second, third, or fourth.

```{r}
rankings <- c("first","second","third","fourth")
# Using `str()` shows the expected order...
str(rankings)

# But using the `table()` function to summarize the data lists them alphabetically:
table(rankings)

```

**How do we fix this to order them logically?**
:::

We use the **Factor** variable type! It lets us specify the expected levels of our categorical data:

```{r}
rankings <- as.factor(rankings)
# If we just make the variable a factor, we still have the same problem:
str(rankings)
table(rankings)

# Instead, we can explicitly tell it the order we want with the "levels" argument:
rankings <- factor(rankings, levels=c("first","second","third","fourth"))
table(rankings)

# We can set the levels to be whatever we want -- for example, we could reverse them:
rankings <- factor(rankings, levels=c("fourth","third","second","first"))
table(rankings)
```

::: {.callout-tip collapse="true"}
##### Extra Credit

Why did `str()` print the rankings in the correct order the very first time, even though `table()` showed that R was treating them alphabetically?

Because we entered the names in the logical order when we created the `rankings` variable. 

If we had created the variable with them out of order, `str()` would print them out of order, but R would still treat them alphabetically:

```{r}
rankings <- c("third","second","fourth","first")
# Prints the silly order we supplied...
str(rankings)
# ...but still treats it alphabetically
table(rankings)

```
:::

Changing the levels of your **Factor** variables can be very useful when it comes to plotting data, as we will see.

### Getting Help

R has a robust help system -- just prepend a `?` to a function's name.

You can search for help in two ways:

-   **Single question mark: `?`**

    -   Displays help documentation for a specific function.
    -   *Example*: `?mean()` shows the documentation for Base-R's `mean` function.
    -   This type of search is best if you know a function's name

-   **Double question mark: `??`**

    -   Searches help documentation for keyword(s).
    -   *Example*: `??mean()` finds all functions (and their documentation) containing `mean` and returns a list that you can select from.
    -   This type of search is useful when you know *what* you want, but not the exact function name. 
    - It's also useful to see if there are multiple functions that do similar things (so you can pick the best one for your needs).
    -   Works best if you use specific keywords since many functions share common words.

`?` is especially useful for checking a function’s arguments (what goes inside the parentheses) and their defaults.

I use `?` all the time -- sometimes just to see what other cool things a function I'm using can do!

### Packages

Did you notice I specified that `mean()` is a function in Base-R? R comes ready-made with many essential statistical and graphical functions.

But one of the best things about R is the community of other users who create **packages** -- collections of related functions to do specific things in R.

R Packages let you do things like calculate RNA-seq gene expression, plot microbiome phylogenetic trees, use machine learning to create statistical models, and more.

These tasks require diverse skills and expertise to program and execute. Thanks to R's broad user base, people make packages to do each of these things (and so much more!).

So how do we get these packages?

-   Almost all packages can be installed with `install.packages("package_name")`.
-   Some bioinformatics tools need to be installed from [Bioconductor](https://www.bioconductor.org/) using `BiocManager::install("package_name")`.
-   Some packages can be installed directly from GitHub using `devtools::install_github("package_name")`.

To load and use a downloaded package, use `library(package_name)`.

::: callout-note
#### Quick notes on packages

-   When installing a package, enclose the name in quotes: `("package_name")`.
-   When loading a package, you don't need the quotes: `(package_name)`.
-   You don't need to *download* a package more than once (though you may need to update it).
-   However, you must *load* a package every time before you can use it.
:::

### Navigating RStudio

Now that you understand the basics, it's time to dive in!

#### Working directories

Remember in our [last lesson](../Command-Line/Command_Line_Exercise.md) when we learned `pwd` to see our HPC directory?

There is a similar command in R:

```{r}
getwd()
```

You can see I'm currently in my project directory on the Zamarin Lab computer.

If we want to *change* the directory, we can use `setwd()`, specifying the path we want to move to:

```{r}
setwd("C:/Users/Zamarin Lab/Documents/GitHub/Umbrella-Academy/R-Project")
```

::: callout-note
`getwd()` = "**get** working directory"

`setwd()` = "**set** working directory"
:::

#### R Projects

Some people strongly believe you should never use `setwd()` in your R scripts. In fact, they even threaten to [come to your office and set your computer on fire🔥](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/).

Rather, they argue for making a folder for your specific project and creating an R Project.

::: {.callout-tip collapse="true"}
##### What is an R Project?

-   A file with the `.Rproj` extension that is associated with a directory
-   “Knows” which files are relevant to a project: when you open the project, RStudio will load those files automatically
-   Automatically sets your working directory to the project folder -- no need to use `setwd()` (and have our computers set on fire🔥)
-   Keeps files organized and reproducible, even if you move directories or switch computers.

Adapted from [*Communicate Data with R*](https://communicate-data-with-r.netlify.app/).
:::

To teach best practices, we will create an R Project for this exercise.

#### RStudio Windows

When you launch RStudio, you will see three panes (or windows).

::: {.callout-caution collapse="true"}
##### Before we progress...

...we need to turn off a few RStudio defaults.

In an ideal world, running your code from start to finish should produce the same result every time.

However, RStudio defaults to *restoring your previous workspace*. Your previous workspace might include objects or data from a different project or version of your code, making it difficult to reproduce your results consistently. More on this [here](https://www.sesync.org/resources/tips-smooth-rstudio-workflow-and-reproducible-r-code).

**To turn off workspace saving and loading:**

-   Go to **Tools -\> Global Options -\> General**
-   Uncheck “Restore .RData into workspace at startup”
-   Change “Save workspace to .RData on exit” to “Never” ![](assets/Global_Options.png)
:::

Now that we've turned off those defaults, let's create a new script:

![Create a new script by going to File -\> New File -\> R Script](assets/New_File.png)

Now you should see something like this:

![**The four RStudio windows.** Yours may be in a different orientation than in this figure. These images and annotations are from the silly yet useful book [*YaRrr! The Pirate’s Guide to R*](https://bookdown.org/ndphillips/YaRrr/)](https://bookdown.org/ndphillips/YaRrr/images/RStudio_Screenshot_Labels.png)

-   **Console**: You can enter and run commands, but they are not saved for future use. (This is the same as in Base-R)
-   **Source**: Write and run scripts.
    -   Can also be opened in Base-R, but there's no "Run" button to execute your code.
    -   That said, it's much better to use a keyboard shortcut to execute your codes -- just type `CTRL + Enter`.
    -   Try that now by typing `getwd()`, followed by `CTRL + Enter`.
    -   This will work in either the **Console** or the **Source**.
    -   If you ran it in the **Console**, you'll note that the command disappeared. Try using the `Up` arrow to retrieve the command and run it again!
-   **Environment/History**: Tracks variables and command history.
    -   We haven't created any variables (yet) to go into the **Environment**
    -   But check out the **History** tab -- you should see the `getwd()` command(s) you just ran!
-   **Files, Plots, Packages, etc.**: Manage files, visualizations, and installed packages. This will also look fairly empty, but not for long!

#### RStudio Projects

Go ahead and close your new script containing the brilliant and groundbreaking code you just wrote (`getwd()`), no need to save it.

Now, create a new project and new directory:

![Create a new project by going to File -\> New Project. Then create a New Directory, and finally New Project.](assets/New_Proj.png)

You can name your new directory whatever you'd like, as long as you remember it's for this project.

Now we'll go back and create a new R script in our project folder.

::: {.callout-note collapse="true"}
##### A note on document types

There are other document types, like R Markdown, or the newer Quarto (this is actually a Quarto document). These file types are a bit more advanced and require you to know Markdown syntax, but can be very helpful for real projects. You can combine code, text, and output seamlessly, which is good for presentation and reproducibility.

If you want to learn more, I highly recommend this course, [*Productive R Workflow*](https://www.productive-r-workflow.com/). Contact me if you are interested; the creator offers group rates for teams.
:::

Okay, so we now have our R Project and our fresh new script. It's time to begin!

## Exercise

```{r}
#| echo: false

library(tidyverse)
library(viridis)
library(readxl)
library(gtExtras)
library(ggExtra)
library(scales)

```

Our goal today is to learn helpful R code to generate beautiful plots.

To make things simple, we will use some example data for the exercise.

Many packages (and Base-R) include test datasets, which are great for exploring functions and testing code.

We will use the `starwars` test dataset from the `tidyverse` package as our example data today.

### Getting Started

I've created an [R Script](Getting_Started_with_R_script.R) with the code needed for this exercise. Go ahead and open that script now.

You can use it as a template as you write your script, but try typing out the commands to build muscle memory 💪

You can copy/paste long names for packages, variables, and files, but typing out functions helps you remember the syntax.

Look for ▶️ icons to know when need to write in your script.

#### Install and Load Packages, Download Data

▶️ First, install and load the required packages (listed at the top of the script).

We'll use the full `starwars` dataset later, but I’ve saved a small version of it to show how to load your own data into R.

Download the [dataset](input/small_star_wars.xlsx) from the GitHub:

![Navigate to the input folder, select the file, and select "Copy raw file."](assets/Download_Data.png) Create a folder in your project directory called `input` and save the file there.

▶️ Then, read in the data with this command:

```{r}
small_star_wars <- read_excel("input/small_star_wars.xlsx", na="NA")
```

If you set up your R Project correctly, this code will run as-is (no need for `setwd()`!).

#### Explore the Data

This dataset is more complicated than the vectors I created earlier.

▶️ What does it look like if we run `str()` on this?

```{r}
str(small_star_wars)
```

This shows that it's a **Tibble** (an upgraded **Data Frame**) containing both numeric and character variables. 

▶️ Use `summary()` for a quick overview:

```{r}
summary(small_star_wars)
```

You can also use the `gtExtras` package to create a polished summary table with very simple code:

```{r}

small_star_wars %>% 
  gt()

```

This code uses the pipe operator (`%>%`) to chain together operations. [Pipes](https://www.geeksforgeeks.org/pipe-in-r/) are useful but a bit advanced.

Since we're only running one operation, you can generate the same table using the `small_star_wars` variable as the argument passed to `gt()`:

```{r}
gt(small_star_wars)
```

::: {.callout-tip collapse="true"}
##### A bit more on pipes (`%>%`)

Using the code below, you can apply a theme to make your `gtExtras` tables look like they do on the New York Times or ESPN.

Here I've given you two examples, one with a pipe and one without.

Which is easier for you to read and understand?

```{r}
#| layout-nrow: 2

# No pipe:
gt_theme_nytimes(gt(small_star_wars))

# With pipe:
small_star_wars %>% 
  gt() %>% 
  gt_theme_espn()
```
:::

With `gtExtras`, you can do some cool things, like grouping variables together and plotting continuous variables right in your table. You can also apply some interesting visual styles:

```{r}
#| layout: [[45,-1, 45, -1, 45], [100]]
#| code-fold: true
#| code-summary: "Show the code"

# These codes are more complex, but I'm including them here for extra credit in case anyone is curious to see how it's done (and how relatively easy it is).

small_star_wars %>%
  select(name, species, homeworld) %>% 
  # Here we select the subset of the total variables we want to include
  group_by(homeworld) %>% 
  # Group them together by one of those variables (here `homeworld`)
  gt() %>%
  gt_theme_pff() 
  # Plot, and then apply a theme

small_star_wars %>%
  select(name, species, homeworld) %>%
  group_by(species) %>%
  gt() %>%
  gt_theme_excel()
  # Same as above, just grouping by `species` and changing the theme

small_star_wars %>%
  select(name, species, hair_color) %>%
  group_by(species) %>%
  gt() %>%
  gt_theme_dot_matrix()
  # Same as above, just looking at hair color and changing the theme

agg_star_wars <- starwars %>%
  # This is a bit more complicated 
  # To show more interesting distributions, I'm using the whole `starwars` dataset to include more data points
  filter(species %in% c("Human", "Droid", "Gungan")) %>% 
  # I'm filtering to just a few species that have more than 2 entries
  select(species, height, mass, birth_year) %>% 
  # Selecting the variables we want to include and grouping by species
  group_by(species) %>%   
  # To make the plots, gtExtras requires your continuous variables to be in list form, so we do that using `summarize` and `list`
  summarize(
    Height = list(height),  
    Weight = list(mass),    
    Born = list(birth_year) 
    # This generates a list, by our grouping variable, of each observation's height, mass, and birth year
  ) # And we save all this as an "aggregated" dataset named `agg_star_wars`

agg_star_wars %>%
  gt() %>%
  gt_plt_dist(        
    Height,
    type = "density" 
    # This is the code to generate the distribution plots, with arguments to tell it what type of plot we want
  ) %>%
  gt_plt_dist(
    Weight,
    type = "boxplot"
  ) %>%
  gt_plt_dist(
    Born,
    type = "rug_strip"
  ) %>% 
  gt_theme_nytimes()
```

▶️ Try making a table with a fun theme!

**Hint:** Use `??gt_theme` to explore available themes.

#### `table()`

`table()` is great for creating frequency tables, showing you how many of one variable (or a combination of variables) are present.

Let's use this function to see how many of each species are in our dataset.

:::{.callout-tip}
In R, when we want to select just one of a multi-part variable (like a Data Frame or Tibble), we use the selection operator: `$`.
:::

▶️ Let's select just the `species` variable from our Tibble to create a table with one row:

```{r}
table(small_star_wars$species)
```

What if we wanted to add additional information? We can make a multi-dimensional table by separating the two variables with a comma.

▶️ Let's look at both species and hair color:

```{r}
table(small_star_wars$hair_color, small_star_wars$species)
```

::: callout-warning
##### Handling Missing Data
Note that R2-D2's hair (or lack thereof) is recorded as `NA`:

```{r}
#| echo: false
small_star_wars %>%
  filter(species %in% c("Droid")) %>% 
  select(name, species, hair_color) %>%
  gt() %>%
  gt_theme_nytimes()

```

When using `table()`, `NA`s are excluded, **but we are not alerted that an observation has been dropped.**

If we only looked at this table, we might think there were no droids in our dataset (poor R2-D2!):

```{r}
#| echo: false
table(small_star_wars$hair_color, small_star_wars$species)
```

If we want to ensure our friend R2 is included, we could recode it so that an `NA` entry for hair becomes `none`:

```{r}
# Recode NA values using replace_na()
# There are many ways to do this, but this is a simple one using the tidyverse package's `mutate` function
small_star_wars <- small_star_wars %>%
  mutate(hair_color = replace_na(hair_color, "none"))

table(small_star_wars$hair_color, small_star_wars$species)

```
There he is! 🤖
:::

▶️ Try making your own table looking at new variables.

**Hint:** If you forget what other variables are in our dataset, you could run `str()` or `summary()`. 

But you can also use one of the best features of RStudio: The **Environment** Tab!

![Click the arrow next to your Tibble's name to expand the details for a quick peek. <br><br>Or, click the little table icon on the right to open it in its own tab.](assets/Environment.png)


### Time to Plot!

Now let's learn how to make some common plots in R!

You can make plots with R's built-in functions, but they aren't especially pretty:
```{r fig.cap="This is a simple scatterplot showing Star Wars charater Height vs. Weight using the Base-R `plot()` function. <br><br>*Note: I dropped Jabba the Hutt from this analysis since he's such a big boi.*"}
#| echo: false

# I'm filtering the full `starwars` dataset to remove Jabba the Hutt
starwars_noHutt <- starwars %>%
  filter(species != "Hutt") %>% 
  select(species, height, mass, birth_year)  

plot(starwars_noHutt$mass, starwars_noHutt$height)

```

Using packages like `ggplot2` (the gold standard for making plots in R), they can be quite beautiful! 

```{r fig.cap="This is the same Height vs. Weight scatterplot made with `ggplot2`. <br><br>I've also added boxplots showing the marginal distribution of each variable, and point size and color now represent species."}
#| code-fold: true
#| code-summary: "Show the code"

# Filter the `starwars` dataset to remove Jabba the Hutt
# (I did this to make the Base-R plot too, but I'm including it here so you can see how I did it)
starwars_noHutt <- starwars %>%
  filter(species != "Hutt") %>% 
  select(species, height, mass, birth_year)  
 
# I'm creating a scatterplot with mass and height on the x- and y-axes, and with color and point size representing species:
p <- ggplot(starwars_noHutt, aes(x = mass, y = height, color = species, size = species)) +
  geom_point() +
  ylim(NA, 250) +
  scale_color_viridis(alpha = 0.5, begin = 0, end = 1, option = "D", aesthetics = "color", discrete = TRUE) +
  theme_light() +
      labs(
        x = "Weight (kg)",
        y = "Height (cm)"
    ) +
  theme(legend.position = "none")

# You can also add elements to show the marginal distributions of the x and y variables
# I'm showing you code for three options, but I only printed the boxplot in the document

# with marginal histogram
p1 <- ggMarginal(p, type="histogram")
 
# marginal density
p2 <- ggMarginal(p, type="density")
 
# marginal boxplot
# I'm making the main plot 10x bigger than the marginal, and increasing the transparency of the outlier points
p3 <- ggMarginal(p, type="boxplot", size=10, alpha=0.5)

p3
```

#### Anatomy of a `ggplot`

Creating a `ggplot` is like adding layers to a "base" graph.

##### Create the canvas and add aesthetics

▶️ Try calling `ggplot()` on its own:
```{r fig.cap="This is like the canvas upon which your `ggplot` is built!"}
ggplot()
```

Next, specify the data (either a Data Frame or Tibble) for your plot. 

We'll stick with our `small_star_wars` Tibble for now to illustrate how to build the plot. 

If you just type `ggplot(small_star_wars)`, you'll get the same blank canvas because we haven't defined *what* to plot. 

To specify this, use the `aes()` argument to map the graph's **aesthetics** -- like variables applied to axes or colors.

Let's pick two random variables for our x and y values and specify them using `aes()`:
```{r}
ggplot(
  small_star_wars,
  aes(
    x=name,
    y=height
  )
)
```

##### Select your plot
Ok, now that we have our canvas and variables, let's choose how to plot the data!

We need to layer on an argument to tell `ggplot()` what kind of plot we want. 

▶️ Let's start with a simple bar plot:
```{r}
ggplot(
  small_star_wars,
  aes(
    x=name,
    y=height
  )
) +
  geom_col()
```

This looks fine, but a bit boring. We can go back to the `aes()` argument and add some more aesthetics. 

▶️ Color the bars by species using `fill`:
```{r}
ggplot(
  small_star_wars,
  aes(
    x=name,
    y=height,
    fill=species
  )
) +
  geom_col()
```

##### Adjust your colors 
:::{.callout-warning}

**The default colors in `ggplot2` aren't very colorblind-friendly.**

:::

[Coblis](https://www.color-blindness.com/coblis-color-blindness-simulator/) is a tool to simulate how colors appear with various types of colorblindness. 

Here I'm simulating **Green-Blind/Deuteranopia** and **Blue-Blind/Tritanopia**, respectively:

::: {layout-ncol=2}

![](assets/Coblis1.png)

![](assets/Coblis2.png)
:::

To address this, I really like the `viridis` package, which has nicely curated palettes that are more accessible and also read well in grayscale.

This is the palette I used for the scatterplot earlier -- let's apply it to our bar graph too:

```{r}
#| echo: false

show_col(pal_viridis()(12))

```

▶️ Let's also simplify the plot by removing `ggplot`'s default gray background. We can do this using a `theme()`:

```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x=name,
    y=height,
    fill=species
  )
) +
  geom_col() +
  scale_color_viridis(alpha=0.7, begin = 0, end = 1, option = "D", aesthetics = "fill", discrete = TRUE) +
  theme_light()
```

This is already starting to look pretty nice, and it's much more colorblind-friendly:

::: {layout-ncol=2}

![](assets/Coblis3.png)

![](assets/Coblis4.png)
:::

▶️ Play around with the color scheme by adjusting the `begin` and `end` numbers, as well as the `option` to change the scale itself. Use `alpha` to change the opacity.

##### Order your variables
You can see R is defaulting to ordering the variables on the x-axis alphabetically. 

By chance, they are nearly in perfect descending order, but what if we wanted to order it precisely?

With only six samples, we could coerce `name` into a factor and then set the levels manually based on the heights we observe. But this is impractical as sample size increases, and also leaves room for human error. 

Here's a simple code to dynamically reorder a factor based on the value of another variable:

```{r}
# First convert `name` to a factor:
small_star_wars$name <- as.factor(small_star_wars$name)

# Use `fct_reorder()` from the `forcats` package to order by `height` (descending)
ggplot(
  small_star_wars,
  aes(
    x=fct_reorder(name, desc(height)),
    y=height,
    fill=species
  )
) +
  geom_col() +
  scale_color_viridis(alpha=0.7, begin = 0, end = 1, option = "D", aesthetics = "fill", discrete = TRUE) +
  theme_light()
```

##### Add your labels
Lastly, a plot is only as good as its labels!

▶️ Add polished labels using `labs()`
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x=fct_reorder(name, desc(height)),
    y=height,
    fill=species
  )
) +
  geom_col() +
  scale_color_viridis(alpha=0.7, begin = 0, end = 1, option = "D", aesthetics = "fill", discrete = TRUE) +
  theme_light() +
  labs(
    x="Character Name",
    y="Height (cm)",
    fill="Star Wars \nSpecies",
    title="Star Wars Character Height",
    subtitle="Character height (in cm) for six primary Star Wars characters, colored by species",
    caption = "Created by me, Kelsey!"
  )
```

##### Putting it all together
To summarize, this is the basic structure of a `ggplot`:

```{r}
#| output: false

ggplot(               # Create your canvas
  small_star_wars,    # Specify your dataset
  aes(                # Define your aesthetics
    x = name,         # X-axis variable
    y = height,       # Y-axis variable
    fill = species,
    size=homeworld    # Other aesthetics (there are many options)
  )                           
) +                   # This is the base upon which to add layers
  geom_col() +        # Layers must include your plot type
  geom_point(         # You can add multiple different geoms, or even multiple of the same type
    aes(
      color = homeworld, 
      size = homeworld) # And each geom can have its own aes()
  ) +  
  theme_bw() +        # I recommend always including a theme to follow good design principles
  labs(               # And always label your graph
    x = "Character Name",
    y = "Height (cm)",
    fill = "Species",
    title = "Star Wars Character Heights (in cm)",
    subtitle = "Bar and point colors mapped to species and homeworld, respectively"
  )


```


```{r}
#| code-fold: true
#| code-summary: "Show the full code"

# I cheated a bit to make the summary section easier to read
# (There are some quirks in the way that the legend is rendered for multiple geoms that require more code to clean up)
# But here is the code you need to reproduce the figure below:

ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(name, desc(height)),
    y = height,
    fill = species
  )
) +
  geom_col() +
  geom_point(
    aes(color = homeworld, size = homeworld) # Map both color and size to the same variable (homeworld)
  ) +
  scale_fill_viridis_d(option = "D", alpha = 0.8, begin = 0.2, end = 0.5) + # Set "fill" colors (species)
  scale_color_viridis_d(option = "C", alpha = 0.9, begin = 0.1, end = 0.9) + # set "color" colors (homeworld)
  guides(
    fill = guide_legend(override.aes = list(shape = NA)), # Remove points from species legend
    color = guide_legend(title = "Homeworld"), # Customize homeworld legend
    size = guide_legend(title = "Homeworld") # Combine size and color legend for homeworld
  ) +
  theme_bw() + # Apply a simple theme
  theme(
    legend.key = element_rect(fill = NA, color = NA) # Remove legend background
  ) +
  labs(
    x = "Character Name",
    y = "Height (cm)",
    fill = "Species",
    title = "Star Wars Character Heights (in cm)",
    subtitle = "Bar and point colors mapped to species and homeworld, respectively"
  )
```

Now you know the building blocks for creating a plot using `ggplot2`!

Let's use those blocks to build some other common plots.

### Discrete Variables
Let's continue plotting discrete (categorical) values.

#### Exploring bar plots
We used `geom_col()` for our bar plot, but `geom_bar()` is a flexible alternative. 

Using `stat="identity"` with `geom_bar()`, we can generate the same plot:

```{r}
#| code-fold: true
#| code-summary: "Show the code"

ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(name, desc(height)),
    y = height,
    fill = species
  )
) +
  geom_bar(stat="identity") +
  scale_color_viridis(alpha=0.7, begin = 0, end = 1, option = "D", aesthetics = "fill", discrete = TRUE) +
  theme_light() +
  labs(
    x = "Character Name",
    y = "Height (cm)",
    fill = "Species"
  )
```

▶️ Now let's use `geom_bar()` to plot height by species, instead of by name.
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(species, desc(height)),
    y = height,
    fill= species
  )
) +
  geom_bar(stat="identity") +
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  theme_light() +
  labs(
    x = "Species",
    y = "Height (cm)",
    fill = "Species"
  )

```
This sums the heights of all the humans in the dataset (not very informative). 

What's a better way to plot this?

▶️ We can plot species on the x-axis but fill by name to get a stacked bar plot, or use `position="dodge"`to plot the names side-by-side
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(species, desc(height)),
    y = height,
    fill= fct_reorder(name, desc(height)) # Sorting the fill factor by height as well plots them in order by descending height within the grouping
  )
) +
  geom_bar(stat="identity") +
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  theme_light() +
  labs(
    x = "Species",
    y = "Height (cm)",
    fill = "Character Name"
  )

ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(species, desc(height)),
    y = height,
    fill= fct_reorder(name, desc(height))
  )
) +
  geom_bar(stat="identity", position="dodge") +
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  theme_light() +
  labs(
    x = "Species",
    y = "Height (cm)",
    fill = "Character Name"
  )
```

We can also plot bar charts as a percentage of the total. 

That doesn't make much sense to do using height, but what if we wanted to show the sex distribution by species?

▶️ Make a plot with percentage on the y-axis by changing `position="dodge"` to `position="fill"`

```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x = species,
    fill= sex
  )
) +
  geom_bar(position="fill") +
  scale_y_continuous(labels = scales::percent) +  # This argument makes the y-axis be in % (otherwise it will go from 0-1)
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  theme_light() +
  labs(
    x = "Species",
    y = "Sex (% of Total)",
    fill = "Sex",
    title = "Proportion of Sex within Each Species",
    subtitle = "Bar plot showing the percentage breakdown of sex by species"
  )
```

Maybe you're interested in the species **and** sex distribution of height for all of our characters -- but now we're running into quite a few variables. 

That's where `facet_wrap()` comes in. It allows you to split out graphs with your variable of interest, to better visualize multi*faceted* data (get it?).

▶️ Plot height by species, separated by sex, with character names indicated by color
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(species, desc(height)),
    y = height,
    fill= fct_reorder(name, desc(height))
  )
) +
  geom_bar(stat="identity", position="dodge") +
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  facet_wrap(~sex) +
  theme_light() +
  labs(
    x = "Species",
    y = "Height (in cm)",
    fill = "Name",
    title = "Character Height by Sex within Each Species"
  )
  
```

To streamline the plot, you can include `scales="free_x` in your `facet_wrap()` argument to drop the unused species in each group:
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars,
  aes(
    x = fct_reorder(species, desc(height)),
    y = height,
    fill= fct_reorder(name, desc(height))
  )
) +
  geom_bar(stat="identity", position="dodge") +
  scale_fill_viridis(option = "C", begin = 0.1, end = 0.9, discrete=TRUE) +
  facet_wrap(~sex, scales ="free_x") +
  theme_light() +
  labs(
    x = "Species",
    y = "Height (in cm)",
    fill = "Name",
    title = "Character Height by Sex within Each Species"
  )
```

#### Lollipop Plots
Lollipop plots are modified bar plots with a cleaner aesthetic: 
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars, 
  aes(
    x=name,
    y=height)) +
  geom_segment( aes(x=name, xend=name, y=0, yend=height), color="skyblue") +
  geom_point(color="#433E85FF", size=4, alpha=0.6) + 
  theme_classic() +
  labs(
    x = "Species",
    y = "Height (in cm)"
  )
```
:::{.callout-tip}
For better readability with long category names or numerous samples, flip the x- and y-axes using `coord_flip()`

:::

▶️ Make a flipped-coordinate lollipop plot
```{r}
#| code-fold: true
#| code-summary: "Show the code"
ggplot(
  small_star_wars, 
  aes(
    x=name,
    y=height)) +
  geom_segment( aes(x=name, xend=name, y=0, yend=height), color="skyblue") + # You can also set colors using text or Hex codes
  geom_point(color="#433E85FF", size=4, alpha=0.6) + 
  theme_classic() +
  labs(
    x = "Species",
    y = "Height (in cm)"
  ) +
  coord_flip()

```
#### Box plots and (their superior cousin) Violin plots
:::{.callout-warning}
Box plots are useful for showing variable distributions, but they can hide important trends in your data.
:::

To illustrate this phenomenon, I'm using a dummy dataset (from [this](https://www.data-to-viz.com/caveat/boxplot.html) excellent explanation of the dangers of box plots).
```{r}
#| echo: false
# create a dataset
data <- data.frame(
  name=c( rep("A",500), rep("B",500), rep("B",500), rep("C",20), rep('D', 100)  ),
  value=c( rnorm(500, 10, 5), rnorm(500, 13, 1), rnorm(500, 18, 1), rnorm(20, 25, 4), rnorm(100, 12, 1) )
)

# Plot
data %>%
  ggplot( aes(x=name, y=value, fill=name)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("A somewhat misleading box plot") +
    xlab("")
```
Let's get a better sense of the true distribution by plotting individual points.

To prevent the points from overlapping too much, we can use `geom_jitter()` to randomly disperse them:
```{r}
#| code-fold: true
#| code-summary: "Show the code"
data %>% 
ggplot( aes(x=name, y=value, fill=name)) +
    geom_boxplot() +
    scale_fill_viridis(discrete = TRUE) +
    geom_jitter(color="darkgrey", size=0.7, alpha=0.6) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("A box plot with jitter") +
    xlab("")
```
We can see that group `C` is much smaller, and `B` seems to have a bimodal distribution, both of which are important to consider when interpreting the data.

:::{.callout-caution collapse=true}
##### A quick warning about `ggplot()` layers
Because a `ggplot` is built iteratively, the order you add each geom matters. 

Look what happens if we add the jitter first, before the box plot:
```{r}
data %>%
  ggplot(aes(x = name, y = value, fill = name)) +
  geom_jitter(color = "grey", size = 0.7, alpha = 0.6) + # Jitter first
  geom_boxplot() +                                       # Then box plot
  scale_fill_viridis(discrete = TRUE) +
  theme_light() +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 11)
  ) +
  ggtitle("Jitter first, then box plot") +
  xlab("")
```
The points are plotted first and are covered by the boxes, preventing us from fully visualizing the distribution.
:::

Violin plots provide a fuller view of the distribution:
```{r fig.cap="I'm not just saying that violin plots are superior because I play the violin -- but it doesn't hurt! 🎻"}
#| code-fold: true
#| code-summary: "Show the code"
# sample size
sample_size = data %>% group_by(name) %>% summarize(num=n())

# Plot
data %>%
  left_join(sample_size) %>%
  mutate(myaxis = paste0(name, "\n", "n=", num)) %>%
  ggplot( aes(x=myaxis, y=value, fill=name)) +
    geom_violin(width=1.4) +
    geom_boxplot(width=0.1, color="grey", alpha=0.2) +
    scale_fill_viridis(discrete = TRUE) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    ggtitle("A violin plot") +
    xlab("")
```
A downside of violin plots is that they don't convey differences in sample size very well.

There's a special plot called a Raincloud Plot that uses box plots, individual observations, *and* distribution plots to show all the information at once:

```{r}
#| code-fold: true
#| code-summary: "Show the code"
library(ggdist)
# Plot
data %>%
  ggplot(aes(x = factor(name), y = value, fill = factor(name))) +
  
  # Add half-violin from {ggdist} package
  stat_halfeye(
    adjust = 0.5,
    justification = -0.2,
    .width = 0,
    point_colour = NA
  ) +
  
  geom_boxplot(
    width = 0.12,
    outlier.color = NA,
    alpha = 0.5
  ) +
  
  stat_dots(
    side = "left",
    justification = 1.1,
    binwidth = NA
  ) +
  
  scale_fill_viridis(discrete = TRUE) +
  theme_light() +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 11)
  ) +
  ggtitle("A raincloud plot example") +
  xlab("")
```

For your practice, let's use the full `starwars` dataset this time, to give us a larger sample size, 

Let's plot height by character sex, to give us more observations per group.

Here's the plain box plot -- I won't have you plot this so you don't learn bad habits 😈
```{r}
#| echo: false
# There are a few NAs for height and sex in the full dataset -- filter those out first.
# Our friend Jabba is also the only hermaphrodite in the data, so let's filter them out too, for plotting purposes
filtered_star_wars <- starwars %>% filter(!is.na(sex), !is.na(height), species!="Hutt")

# Plain Box Plot
ggplot( 
  filtered_star_wars,
  aes(x=sex, y=height, fill=sex)) +
    geom_boxplot() +
    scale_fill_viridis(alpha=0.7, begin = 0.2, end = 0.7, option = "D", aesthetics = "fill", discrete = TRUE) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    labs(
    x = "Character Sex",
    y = "Height (in cm)",
    title = "Star Wars Height by Character Sex",
    subtitle = "Plain Box Plot"
  ) 
```

▶️ Try plotting a box plot with `geom_jitter()`:
```{r}
#| code-fold: true
#| code-summary: "Show the code"
# There are a few NAs for height and sex in the full dataset -- filter those out first.
# Our friend Jabba is also the only hermaphrodite in the data, so let's filter them out too, for plotting purposes
filtered_star_wars <- starwars %>% filter(!is.na(sex), !is.na(height), species!="Hutt")

# Box Plot with jitter
ggplot( 
  filtered_star_wars,
  aes(x=sex, y=height, fill=sex)) +
    geom_boxplot() +
    scale_fill_viridis(alpha=0.7, begin = 0.2, end = 0.7, option = "D", aesthetics = "fill", discrete = TRUE) +
    geom_jitter(color = "darkgray", size = 0.7, alpha = 0.7) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    labs(
    x = "Character Sex",
    y = "Height (in cm)",
    title = "Star Wars Height by Character Sex",
    subtitle = "Box Plot with Jitter"
  ) 
```
▶️ Now try a violin plot!
```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Violin plot
ggplot( 
  filtered_star_wars,
  aes(x=sex, y=height, fill=sex)) +
    geom_violin(width=1.4) +
    geom_boxplot(width=0.1, color="darkgrey", alpha=0.2) +
    scale_fill_viridis(alpha=0.7, begin = 0.2, end = 0.7, option = "D", aesthetics = "fill", discrete = TRUE) +
    theme_light() +
    theme(
      legend.position="none",
      plot.title = element_text(size=11)
    ) +
    labs(
    x = "Character Sex",
    y = "Height (in cm)",
    title = "Star Wars Height by Character Sex",
    subtitle = "Violin Plot with Superimposed Box Plot"
  ) 
```

## Continuous Variables
 
Let's move on to plotting continuous variables.

## Placeholder for tomorrow

#### Scatterplots 
Scatterplots effectively visualize relationships between two continuous variables.

### More (including box and violin plots, heatmap)

### Final Thoughts 
By now, you should feel comfortable building a variety of plots in R using ggplot2. Feel free to revisit this guide as you apply these skills to your own data.
